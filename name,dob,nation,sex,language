LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/minhnhatdanchoi/dataset/23e08c5646f693aab629dcb5b698de8d51bb6bc6/name_lang.csv' AS row
// Convert the Languages dictionary string to valid JSON
WITH row, apoc.text.replace(row.Languages, "None", "null") AS temp
WITH row, apoc.text.replace(temp, "'", "\"") AS langJson
// Convert the JSON string to a map
WITH row, apoc.convert.fromJsonMap(langJson) AS langMap
MERGE (e:Employee {name: row.Name})
ON CREATE SET e.nationality = row.Nationality, e.sex = row.Sex, e.dob = row.DOB

MERGE (d:dob {name: row.DOB})
MERGE (e)-[:BIRTH_YEAR]->(d)

FOREACH (_ IN CASE WHEN row.Nationality IS NOT NULL AND trim(row.Nationality) <> "" THEN [1] ELSE [] END |
  MERGE (nat:Nationality {name: row.Nationality})
  MERGE (e)-[:HAS_NATIONALITY]->(nat)
)

FOREACH (_ IN CASE WHEN row.Sex IS NOT NULL AND trim(row.Sex) <> "" THEN [1] ELSE [] END |
  MERGE (s:Sex {name: row.Sex})
  MERGE (e)-[:HAS_SEX]->(s)
)

WITH row, langMap, e
UNWIND keys(langMap) AS lang
MERGE (l:Language {name: lang})
MERGE (e)-[:LANGUAGE]->(l)
FOREACH (lvl IN CASE WHEN langMap[lang] IS NOT NULL AND langMap[lang] <> "" THEN [langMap[lang]] ELSE [] END |
  MERGE (lev:Level {name: lvl})
  MERGE (l)-[:LEVEL]->(lev)
)

new
//senirority
// lang-level
//e-level
'''
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/minhnhatdanchoi/dataset/5b8c6c03157b088722dd84093d07debc2121ba73/name_lang_seniority.csv' AS row

// Convert the Languages dictionary string to valid JSON
WITH row, apoc.text.replace(row.Languages, "None", "null") AS temp
WITH row, apoc.text.replace(temp, "'", "\"") AS langJson

// Convert the JSON string to a map
WITH row, apoc.convert.fromJsonMap(langJson) AS langMap
MERGE (e:Employee {name: row.Name})
ON CREATE SET e.nationality = row.Nationality, e.sex = row.Sex, e.dob = row.DOB,
e.sen=row.Seniority

// Create Nationality node and relationship
MERGE (n:Nationality {name: row.Nationality})
MERGE (e)-[:HAS_NATIONALITY]->(n)

// Create Sex node and relationship
MERGE (s:Sex {type: row.Sex})
MERGE (e)-[:HAS_SEX]->(s)

FOREACH (_ IN
CASE
  WHEN row.Seniority IS NOT NULL AND TRIM (row.Seniority) <> "" THEN [1]
  ELSE []
END |
MERGE (sen:Seniority {name: row.Seniority})
MERGE (e)-[:HAS_SENIORITY]->(sen))

WITH row, langMap, e
UNWIND keys(langMap) AS lang
MERGE (l:Language {name: lang})
MERGE (e)-[:LANGUAGE]->(l)
WITH e, l, lang, langMap[lang] AS lvlValue
// If a level exists, create a Level node and a relationship directly from the employee
FOREACH (_ IN CASE WHEN lvlValue IS NOT NULL AND lvlValue <> "" THEN [1] ELSE [] END |
  MERGE (lev:Level {name: lvlValue})
  MERGE (l)-[:HAS_LEVEL]->(lev)
  MERGE (e)-[:HAS_LANGUAGE_LEVEL {language: lang}]->(lev)
)
'''